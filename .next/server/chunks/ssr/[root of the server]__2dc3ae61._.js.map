{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/config/mcp-servers.ts"],"sourcesContent":["\nimport { Brain } from 'lucide-react';\nimport type { McpServerRegistry } from '@/types/mcp';\n\nexport const MCP_SERVER_CONFIGS: McpServerRegistry = {\n  'sequential-thinking': {\n    id: 'sequential-thinking',\n    name: 'Sequential Thinking MCP',\n    description: 'An MCP server for dynamic and reflective problem-solving through a structured thinking process.',\n    processConfig: {\n      command: 'npx', // Using npx to ensure tsx is resolved\n      args: ['tsx', 'src/mcp-servers/sequential-thinking-server.ts'],\n      // cwd: process.cwd(), // Optional: specify current working directory if needed\n    },\n    icon: Brain,\n    tags: ['Problem Solving', 'AI', 'Reflection'],\n    autoConnect: true, // Attempt to connect to this server on application startup\n  },\n  // Future MCP server configurations can be added here.\n  // Example:\n  // 'filesystem': {\n  //   id: 'filesystem',\n  //   name: 'Filesystem MCP',\n  //   description: 'Provides tools for interacting with the local filesystem.',\n  //   processConfig: {\n  //     command: 'npx',\n  //     args: ['@modelcontextprotocol/server-filesystem', './workspace'], // Example path\n  //   },\n  //   icon: Folder, \n  //   tags: ['Files', 'Storage', 'Local'],\n  //   autoConnect: false,\n  // },\n};\n"],"names":[],"mappings":";;;AACA;;AAGO,MAAM,qBAAwC;IACnD,uBAAuB;QACrB,IAAI;QACJ,MAAM;QACN,aAAa;QACb,eAAe;YACb,SAAS;YACT,MAAM;gBAAC;gBAAO;aAAgD;QAEhE;QACA,MAAM,oMAAA,CAAA,QAAK;QACX,MAAM;YAAC;YAAmB;YAAM;SAAa;QAC7C,aAAa;IACf;AAeF","debugId":null}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/actions/mcp-actions.ts"],"sourcesContent":["\n'use server';\n\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport { spawn, type ChildProcess } from 'child_process';\nimport type { ToolDefinition as SdkToolDefinition } from '@modelcontextprotocol/sdk/types.js'; // Renamed to avoid conflict if McpTool is also named ToolDefinition\nimport { MCP_SERVER_CONFIGS } from '@/config/mcp-servers';\nimport type { McpServerConfig, McpServerRegistry, McpTool } from '@/types/mcp';\n\n// Define ToolDefinition locally if it's just a subset or re-export from SDK\n// For now, assuming McpTool from @/types/mcp is sufficient for internal mapping,\n// and SdkToolDefinition is what the SDK provides.\n\ninterface MCPConnection {\n  client: Client;\n  process: ChildProcess;\n  tools: SdkToolDefinition[]; // Tools as defined by the MCP SDK\n  serverConfig: McpServerConfig; // Store the original config for reference\n}\n\nclass MCPManager {\n  private connections = new Map<string, MCPConnection>();\n  private managerIsInitialized = false;\n\n  constructor() {\n    // Constructor is clean of Node.js process global event listeners\n  }\n\n  public isManagerInitialized(): boolean {\n    return this.managerIsInitialized;\n  }\n\n  public async initialize(serverRegistry: McpServerRegistry): Promise<void> {\n    if (this.managerIsInitialized) {\n      console.log('MCPManager already initialized.');\n      return;\n    }\n    console.log('MCPManager: Initializing...');\n    const connectionPromises = Object.values(serverRegistry)\n      .filter(config => config.autoConnect)\n      .map(config => this.connectServer(config));\n    \n    await Promise.allSettled(connectionPromises);\n    this.managerIsInitialized = true;\n    console.log('MCPManager: Initialization complete. Connected servers:', Array.from(this.connections.keys()));\n  }\n\n  async connectServer(serverConfig: McpServerConfig): Promise<void> {\n    if (this.connections.has(serverConfig.id)) {\n      console.log(`MCPManager: Server ${serverConfig.id} is already connected or connection attempt in progress.`);\n      return;\n    }\n\n    console.log(`MCPManager: Attempting to connect to ${serverConfig.name} (ID: ${serverConfig.id})...`);\n\n    let serverProcess: ChildProcess;\n\n    try {\n      serverProcess = spawn(serverConfig.processConfig.command, serverConfig.processConfig.args, {\n        stdio: ['pipe', 'pipe', 'pipe'], \n        env: { ...process.env, ...serverConfig.processConfig.env, NODE_ENV: process.env.NODE_ENV },\n        cwd: serverConfig.processConfig.cwd,\n      });\n      \n      serverProcess.stderr?.on('data', (data) => {\n        console.error(`MCP Server [${serverConfig.id}] stderr: ${data.toString().trim()}`);\n      });\n\n      serverProcess.on('error', (err) => {\n        console.error(`MCPManager: Failed to start server process for ${serverConfig.id}:`, err);\n        this.connections.delete(serverConfig.id); \n      });\n\n      serverProcess.on('exit', (code, signal) => {\n        console.log(`MCPManager: Server process ${serverConfig.id} exited with code ${code} and signal ${signal}`);\n        this.connections.delete(serverConfig.id);\n      });\n      \n      const transport = new StdioClientTransport({\n        reader: serverProcess.stdout,\n        writer: serverProcess.stdin,\n      });\n\n      const client = new Client(\n        { name: 'agent-computer-client', version: '1.0.0' }, \n        { capabilities: {} } \n      );\n\n      await client.connect(transport);\n      console.log(`MCPManager: Successfully established transport with ${serverConfig.name}.`);\n\n      let tools: SdkToolDefinition[] = [];\n      try {\n        const toolsResponse = await client.request<{ tools: SdkToolDefinition[] }>({ method: 'tools/list' }, {});\n        tools = toolsResponse?.tools || [];\n        console.log(`MCPManager: Fetched ${tools.length} tools from ${serverConfig.name}.`);\n      } catch (toolError) {\n        console.error(`MCPManager: Failed to list tools for ${serverConfig.name}:`, toolError);\n         await client.close();\n         if (serverProcess && !serverProcess.killed) serverProcess.kill();\n         throw toolError; \n      }\n\n      this.connections.set(serverConfig.id, {\n        client,\n        process: serverProcess,\n        tools,\n        serverConfig \n      });\n\n      console.log(`✓ MCPManager: Connected to ${serverConfig.name} (ID: ${serverConfig.id}).`);\n    } catch (error) {\n      console.error(`✗ MCPManager: Failed to connect to ${serverConfig.name} (ID: ${serverConfig.id}):`, error);\n      if (serverProcess && !serverProcess.killed) {\n        serverProcess.kill();\n      }\n      this.connections.delete(serverConfig.id);\n      // Do not re-throw here if initialize is called with allSettled,\n      // as individual connection failures are handled by allSettled.\n      // However, if connectServer is called directly, re-throwing might be desired.\n      // For now, let's assume initialize handles aggregation of results/errors.\n    }\n  }\n\n  listTools(serverId: string): SdkToolDefinition[] {\n    const connection = this.connections.get(serverId);\n    if (!connection) {\n      throw new Error(`MCPManager: Server ${serverId} not connected or connection lost.`);\n    }\n    return connection.tools;\n  }\n\n  listAllAvailableTools(): McpTool[] {\n    const allTools: McpTool[] = [];\n    for (const [serverId, connection] of this.connections.entries()) {\n      const serverTools = connection.tools || [];\n      allTools.push(...serverTools.map(tool => ({\n        name: tool.name,\n        description: tool.description,\n        inputSchema: tool.inputSchema || {}, \n        serverId: serverId,\n      })));\n    }\n    return allTools;\n  }\n  \n  getConnectedServersInfo(serverRegistryInput: McpServerRegistry): Array<Pick<McpServerConfig, 'id' | 'name' | 'description' | 'icon' | 'tags'> & {toolsCount: number}> {\n    const info: Array<Pick<McpServerConfig, 'id' | 'name' | 'description' | 'icon' | 'tags'> & {toolsCount: number}> = [];\n     for (const [serverId, connection] of this.connections.entries()) {\n        const originalConfig = connection.serverConfig;\n        info.push({\n            id: serverId,\n            name: originalConfig.name, \n            description: originalConfig.description,\n            icon: originalConfig.icon,\n            tags: originalConfig.tags,\n            toolsCount: connection.tools.length,\n        });\n    }\n    return info;\n  }\n\n  async executeTool(serverId: string, toolName: string, args: any = {}): Promise<any> {\n    const connection = this.connections.get(serverId);\n    if (!connection) {\n      throw new Error(`MCPManager: Server ${serverId} not connected or connection lost.`);\n    }\n\n    console.log(`MCPManager: Executing tool \"${toolName}\" on server \"${serverId}\" with args:`, args);\n    try {\n      const response = await connection.client.request(\n        { method: 'tools/call' },\n        { name: toolName, arguments: args }\n      );\n      console.log(`MCPManager: Tool \"${toolName}\" executed successfully on \"${serverId}\". Response:`, response);\n      return response;\n    } catch (error) {\n      console.error(`MCPManager: Error executing tool \"${toolName}\" on server \"${serverId}\":`, error);\n      throw error;\n    }\n  }\n\n  async disconnect(serverId: string): Promise<void> {\n    const connection = this.connections.get(serverId);\n    if (connection) {\n      console.log(`MCPManager: Disconnecting from server ${serverId}...`);\n      try {\n        await connection.client.close();\n      } catch (closeError) {\n        console.error(`MCPManager: Error closing client for ${serverId}:`, closeError);\n      }\n      if (connection.process && !connection.process.killed) {\n        connection.process.kill('SIGTERM'); \n        await new Promise(resolve => setTimeout(resolve, 200)); \n        if (connection.process && !connection.process.killed) {\n            console.log(`MCPManager: Server process ${serverId} did not terminate with SIGTERM, sending SIGKILL.`);\n            connection.process.kill('SIGKILL');\n        }\n      }\n      this.connections.delete(serverId);\n      console.log(`MCPManager: Disconnected from server ${serverId}.`);\n    }\n  }\n\n  async disconnectAll(): Promise<void> {\n    console.log('MCPManager: Disconnecting all server connections...');\n    const disconnectionPromises = Array.from(this.connections.keys()).map(serverId => this.disconnect(serverId));\n    await Promise.allSettled(disconnectionPromises);\n    this.connections.clear();\n    console.log('MCPManager: All server connections closed and processes terminated.');\n    this.managerIsInitialized = false;\n  }\n}\n\n\n// Singleton instance management for MCPManager within this server module\nlet mcpManagerInstance: MCPManager | null = null;\nlet managerInitializationPromise: Promise<void> | null = null;\n\nasync function getInitializedManager(): Promise<MCPManager> {\n  if (mcpManagerInstance && mcpManagerInstance.isManagerInitialized()) {\n    return mcpManagerInstance;\n  }\n\n  if (!managerInitializationPromise) {\n    console.log('MCP Actions: MCPManager instance or initialization promise not found. Creating new one.');\n    if (!mcpManagerInstance) { // Create instance only if it truly doesn't exist\n        mcpManagerInstance = new MCPManager();\n    }\n    managerInitializationPromise = mcpManagerInstance.initialize(MCP_SERVER_CONFIGS)\n      .then(() => {\n        console.log('MCP Actions: MCPManager initialized successfully.');\n      })\n      .catch((error) => {\n        console.error('MCP Actions: MCPManager initialization failed:', error);\n        mcpManagerInstance = null; \n        managerInitializationPromise = null;\n        throw error; \n      });\n  } else {\n    console.log('MCP Actions: Waiting for existing MCPManager initialization promise to complete.');\n  }\n  \n  await managerInitializationPromise;\n\n  if (!mcpManagerInstance) { // Check again after await\n    throw new Error('MCP Actions: MCPManager instance is null after initialization attempt.');\n  }\n  return mcpManagerInstance;\n}\n\nexport async function initializeAndListToolsAction(): Promise<{ tools: McpTool[]; connectedServerIds: string[] }> {\n  try {\n    const manager = await getInitializedManager();\n    const tools = manager.listAllAvailableTools();\n    // Get connected server IDs from the manager's connections map keys\n    const connectedServerIds = Array.from(manager['connections'].keys());\n    return { tools, connectedServerIds };\n  } catch (error) {\n    console.error('Error in initializeAndListToolsAction:', error);\n    return { tools: [], connectedServerIds: [] }; \n  }\n}\n\nexport async function executeMcpToolAction(serverId: string, toolName: string, args: any): Promise<any> {\n  try {\n    const manager = await getInitializedManager();\n    return await manager.executeTool(serverId, toolName, args);\n  } catch (error) {\n    console.error(`Error in executeMcpToolAction for ${toolName} on ${serverId}:`, error);\n    throw error; \n  }\n}\n\nexport async function getConnectedMcpServersInfoAction(): Promise<Array<Pick<McpServerConfig, 'id' | 'name' | 'description' | 'icon' | 'tags'> & {toolsCount: number}>> {\n    try {\n        const manager = await getInitializedManager();\n        return manager.getConnectedServersInfo(MCP_SERVER_CONFIGS);\n    } catch (error) {\n        console.error('Error in getConnectedMcpServersInfoAction:', error);\n        return [];\n    }\n}\n\nexport async function disconnectAllMcpServersAction(): Promise<void> {\n  if (mcpManagerInstance) {\n    try {\n      await mcpManagerInstance.disconnectAll();\n      mcpManagerInstance = null;\n      managerInitializationPromise = null; \n      console.log('MCP Actions: All MCP servers disconnected and manager reset.');\n    } catch (error) {\n      console.error('Error in disconnectAllMcpServersAction:', error);\n      throw error;\n    }\n  } else {\n    console.log('MCP Actions: No MCP manager instance to disconnect.');\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 552, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.0-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 573, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/orchestrate-task-flow.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview An AI-powered orchestration agent that plans tasks across multiple tools.\n *\n * - orchestrateTask - A function that analyzes a user's goal and proposes a plan involving relevant tools.\n * - OrchestrateTaskInput - The input type for the orchestrateTask function.\n * - OrchestrateTaskOutput - The return type for the orchestrateTask function.\n * - ToolInfo - A simplified tool representation for the AI.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst ToolInfoSchema = z.object({\n  id: z.string().describe('The unique identifier for the tool.'),\n  name: z.string().describe('The display name of the tool.'),\n  description: z.string().describe('A brief description of what the tool does.'),\n});\nexport type ToolInfo = z.infer<typeof ToolInfoSchema>;\n\nconst OrchestrateTaskInputSchema = z.object({\n  userGoal: z.string().describe('The high-level goal or task described by the user.'),\n  availableTools: z.array(ToolInfoSchema).describe('A list of available tools with their IDs, names, and descriptions.'),\n});\nexport type OrchestrateTaskInput = z.infer<typeof OrchestrateTaskInputSchema>;\n\nconst OrchestrateTaskOutputSchema = z.object({\n  planSteps: z.array(z.string()).describe('A list of textual steps the agent proposes to achieve the goal. Each step should clearly mention which tool might be used, if any.'),\n  identifiedToolIds: z.array(z.string()).describe('An array of tool IDs identified as relevant to the plan. The order might suggest a sequence.'),\n  clarificationQuestion: z.string().optional().describe('A question the agent asks if the user_s goal is ambiguous or needs more details. The agent should prefer to ask for clarification if the goal is too vague to make a concrete plan.'),\n  agentThoughtProcess: z.string().optional().describe('A brief, user-friendly explanation of the agent_s reasoning or how it arrived at the plan.'),\n});\nexport type OrchestrateTaskOutput = z.infer<typeof OrchestrateTaskOutputSchema>;\n\nexport async function orchestrateTask(input: OrchestrateTaskInput): Promise<OrchestrateTaskOutput> {\n  return orchestrateTaskFlow(input);\n}\n\nconst orchestrateTaskPrompt = ai.definePrompt({\n  name: 'orchestrateTaskPrompt',\n  input: {schema: OrchestrateTaskInputSchema},\n  output: {schema: OrchestrateTaskOutputSchema},\n  prompt: `You are an Orchestration Agent for Agent-Computer. Your role is to help users achieve complex goals by planning tasks that may involve one or more specialized tools. You do NOT execute the tasks yourself, but you create a plan and identify the tools.\n\nUser's Goal:\n{{{userGoal}}}\n\nAvailable Tools:\n{{#each availableTools}}\n- ID: {{id}}, Name: \"{{name}}\", Description: \"{{description}}\"\n{{/each}}\n\nYour Task:\n1.  Analyze the user's goal.\n2.  Based on the goal and the available tools, identify up to 3 relevant tools that can help achieve this goal. If no specific tools seem directly relevant but the task is general (e.g., 'write a poem'), suggest a general approach or using a generic tool like a Document Processor.\n3.  Formulate a concise, step-by-step plan (max 5 steps). Each step should be actionable. If a tool is relevant for a step, mention it.\n4.  If the user's goal is too vague, ambiguous, or requires information you don't have (e.g., specific dates, preferences), prioritize asking a clear clarification question instead of making too many assumptions.\n5.  Provide a brief, user-friendly \"Thought Process\" (1-2 sentences) explaining your reasoning for the plan and tool selection.\n6.  Populate the 'identifiedToolIds' array with the IDs of the tools you've chosen, in the order they might be used if sequential.\n7.  Return the plan, identified tool IDs, an optional clarification question, and your thought process.\n\nExample Output for a clear goal:\n{\n  \"planSteps\": [\n    \"1. Use 'Document Processor' to draft the initial report outline.\",\n    \"2. Utilize 'Web Navigator' to research market statistics for section 3.\",\n    \"3. Incorporate research into the draft using 'Document Processor'.\"\n  ],\n  \"identifiedToolIds\": [\"document-processor\", \"web-navigator\", \"document-processor\"],\n  \"agentThoughtProcess\": \"The user wants to create a report. I'll start with drafting in the Document Processor, then use the Web Navigator for research, and finally update the document.\"\n}\n\nExample Output for a vague goal:\n{\n  \"planSteps\": [],\n  \"identifiedToolIds\": [],\n  \"clarificationQuestion\": \"To help you organize your Tokyo trip, could you please provide the dates for your travel?\",\n  \"agentThoughtProcess\": \"The user's goal is to plan a trip, which is broad. I need specific dates to proceed with planning flights and accommodation.\"\n}\n\nIf the goal is very simple and seems to only require one tool, create a short plan and identify that tool.\nFocus on planning and tool identification, not execution.\n`,\n});\n\nconst orchestrateTaskFlow = ai.defineFlow(\n  {\n    name: 'orchestrateTaskFlow',\n    inputSchema: OrchestrateTaskInputSchema,\n    outputSchema: OrchestrateTaskOutputSchema,\n  },\n  async input => {\n    const {output} = await orchestrateTaskPrompt(input);\n    if (!output) {\n      // Fallback or error handling if AI output is empty\n      return {\n        planSteps: [\"I'm having trouble formulating a plan right now. Could you try rephrasing your goal?\"],\n        identifiedToolIds: [],\n        agentThoughtProcess: \"Encountered an unexpected issue generating the plan.\"\n      };\n    }\n    return output;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;;CAOC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,iBAAiB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC9B,IAAI,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACxB,MAAM,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC1B,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACnC;AAGA,MAAM,6BAA6B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC1C,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC9B,gBAAgB,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,gBAAgB,QAAQ,CAAC;AACnD;AAGA,MAAM,8BAA8B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC3C,WAAW,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ,CAAC;IACxC,mBAAmB,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ,CAAC;IAChD,uBAAuB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IACtD,qBAAqB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;AACtD;AAGO,eAAe,uCAAa,GAAb,gBAAgB,KAA2B;IAC/D,OAAO,oBAAoB;AAC7B;AAEA,MAAM,wBAAwB,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC5C,MAAM;IACN,OAAO;QAAC,QAAQ;IAA0B;IAC1C,QAAQ;QAAC,QAAQ;IAA2B;IAC5C,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCX,CAAC;AACD;AAEA,MAAM,sBAAsB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACvC;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,sBAAsB;IAC7C,IAAI,CAAC,QAAQ;QACX,mDAAmD;QACnD,OAAO;YACL,WAAW;gBAAC;aAAuF;YACnG,mBAAmB,EAAE;YACrB,qBAAqB;QACvB;IACF;IACA,OAAO;AACT;;;IApEoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 690, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/web-navigator-summarization.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview A web navigator summarization AI agent.\n *\n * - summarizeWebpage - A function that handles the webpage summarization process.\n * - SummarizeWebpageInput - The input type for the summarizeWebpage function.\n * - SummarizeWebpageOutput - The return type for the summarizeWebpage function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst SummarizeWebpageInputSchema = z.object({\n  url: z.string().describe('The URL of the webpage to summarize.'),\n});\nexport type SummarizeWebpageInput = z.infer<typeof SummarizeWebpageInputSchema>;\n\nconst SummarizeWebpageOutputSchema = z.object({\n  summary: z.string().describe('The summary of the webpage.'),\n});\nexport type SummarizeWebpageOutput = z.infer<typeof SummarizeWebpageOutputSchema>;\n\nexport async function summarizeWebpage(input: SummarizeWebpageInput): Promise<SummarizeWebpageOutput> {\n  return summarizeWebpageFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'summarizeWebpagePrompt',\n  input: {schema: SummarizeWebpageInputSchema},\n  output: {schema: SummarizeWebpageOutputSchema},\n  prompt: `You are an expert web content summarizer.\n\nYou will receive a URL of a webpage, and your job is to summarize the content of the webpage.\n\nURL: {{{url}}}`,\n});\n\nconst summarizeWebpageFlow = ai.defineFlow(\n  {\n    name: 'summarizeWebpageFlow',\n    inputSchema: SummarizeWebpageInputSchema,\n    outputSchema: SummarizeWebpageOutputSchema,\n  },\n  async input => {\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,8BAA8B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC3C,KAAK,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC3B;AAGA,MAAM,+BAA+B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC5C,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC/B;AAGO,eAAe,uCAAc,GAAd,iBAAiB,KAA4B;IACjE,OAAO,qBAAqB;AAC9B;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ;IAA2B;IAC3C,QAAQ;QAAC,QAAQ;IAA4B;IAC7C,QAAQ,CAAC;;;;cAIG,CAAC;AACf;AAEA,MAAM,uBAAuB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACxC;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IAxBoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 751, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/ai-assisted-drafting.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview An AI-assisted drafting flow for generating initial document drafts.\n *\n * - aiAssistedDrafting - A function that generates a document draft based on a user prompt.\n * - AiAssistedDraftingInput - The input type for the aiAssistedDrafting function.\n * - AiAssistedDraftingOutput - The return type for the aiAssistedDrafting function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst AiAssistedDraftingInputSchema = z.object({\n  prompt: z.string().describe('A prompt describing the desired document draft.'),\n});\nexport type AiAssistedDraftingInput = z.infer<typeof AiAssistedDraftingInputSchema>;\n\nconst AiAssistedDraftingOutputSchema = z.object({\n  draft: z.string().describe('The generated document draft.'),\n});\nexport type AiAssistedDraftingOutput = z.infer<typeof AiAssistedDraftingOutputSchema>;\n\nexport async function aiAssistedDrafting(input: AiAssistedDraftingInput): Promise<AiAssistedDraftingOutput> {\n  return aiAssistedDraftingFlow(input);\n}\n\nconst aiAssistedDraftingPrompt = ai.definePrompt({\n  name: 'aiAssistedDraftingPrompt',\n  input: {schema: AiAssistedDraftingInputSchema},\n  output: {schema: AiAssistedDraftingOutputSchema},\n  prompt: `You are an AI assistant helping a user draft a document.\n  Based on the user's prompt, generate an initial draft of the document.\n  Prompt: {{{prompt}}}`,  \n});\n\nconst aiAssistedDraftingFlow = ai.defineFlow(\n  {\n    name: 'aiAssistedDraftingFlow',\n    inputSchema: AiAssistedDraftingInputSchema,\n    outputSchema: AiAssistedDraftingOutputSchema,\n  },\n  async input => {\n    const {output} = await aiAssistedDraftingPrompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,gCAAgC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC7C,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC9B;AAGA,MAAM,iCAAiC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC9C,OAAO,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC7B;AAGO,eAAe,uCAAgB,GAAhB,mBAAmB,KAA8B;IACrE,OAAO,uBAAuB;AAChC;AAEA,MAAM,2BAA2B,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC/C,MAAM;IACN,OAAO;QAAC,QAAQ;IAA6B;IAC7C,QAAQ;QAAC,QAAQ;IAA8B;IAC/C,QAAQ,CAAC;;sBAEW,CAAC;AACvB;AAEA,MAAM,yBAAyB,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC1C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,yBAAyB;IAChD,OAAO;AACT;;;IAtBoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 810, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/smart-suggestions.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview This file defines a Genkit flow for providing smart suggestions to users based on the currently active tool in the Space.\n *\n * - getSmartSuggestions - A function that returns smart suggestions based on the active tool.\n * - SmartSuggestionsInput - The input type for the getSmartSuggestions function.\n * - SmartSuggestionsOutput - The return type for the getSmartSuggestions function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst SmartSuggestionsInputSchema = z.object({\n  activeTool: z\n    .string()\n    .describe('The name of the currently active tool in the Space.'),\n});\nexport type SmartSuggestionsInput = z.infer<typeof SmartSuggestionsInputSchema>;\n\nconst SmartSuggestionsOutputSchema = z.object({\n  suggestions: z\n    .array(z.string())\n    .describe('An array of smart suggestions for the user.'),\n});\nexport type SmartSuggestionsOutput = z.infer<typeof SmartSuggestionsOutputSchema>;\n\nexport async function getSmartSuggestions(input: SmartSuggestionsInput): Promise<SmartSuggestionsOutput> {\n  return smartSuggestionsFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'smartSuggestionsPrompt',\n  input: {schema: SmartSuggestionsInputSchema},\n  output: {schema: SmartSuggestionsOutputSchema},\n  prompt: `You are an AI assistant that provides smart suggestions to users based on the currently active tool in the Space.\n\n  The suggestions should be related to the tool and help the user discover new functionalities and optimize their workflow.\n\n  Current Tool: {{{activeTool}}}\n\n  Provide 3-5 suggestions in bullet point format.\n\n  Example Output:\n  {\n    \"suggestions\": [\n      \"Suggestion 1\",\n      \"Suggestion 2\",\n      \"Suggestion 3\",\n      \"Suggestion 4\",\n      \"Suggestion 5\"\n    ]\n  }\n  `,\n});\n\nconst smartSuggestionsFlow = ai.defineFlow(\n  {\n    name: 'smartSuggestionsFlow',\n    inputSchema: SmartSuggestionsInputSchema,\n    outputSchema: SmartSuggestionsOutputSchema,\n  },\n  async input => {\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,8BAA8B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC3C,YAAY,uIAAA,CAAA,IAAC,CACV,MAAM,GACN,QAAQ,CAAC;AACd;AAGA,MAAM,+BAA+B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC5C,aAAa,uIAAA,CAAA,IAAC,CACX,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IACd,QAAQ,CAAC;AACd;AAGO,eAAe,uCAAiB,GAAjB,oBAAoB,KAA4B;IACpE,OAAO,qBAAqB;AAC9B;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ;IAA2B;IAC3C,QAAQ;QAAC,QAAQ;IAA4B;IAC7C,QAAQ,CAAC;;;;;;;;;;;;;;;;;;EAkBT,CAAC;AACH;AAEA,MAAM,uBAAuB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACxC;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IAtCoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 885, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 965, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/agent-computer-layout.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/agent-computer-layout.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/agent-computer-layout.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAqS,GAClU,mEACA","debugId":null}},
    {"offset": {"line": 979, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/agent-computer-layout.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/agent-computer-layout.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/agent-computer-layout.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAiR,GAC9S,+CACA","debugId":null}},
    {"offset": {"line": 993, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 1003, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx"],"sourcesContent":["import AgentComputerLayout from './agent-computer-layout';\n\nexport default function Home() {\n  return <AgentComputerLayout />;\n}\n"],"names":[],"mappings":";;;;AAAA;;;AAEe,SAAS;IACtB,qBAAO,8OAAC,0IAAA,CAAA,UAAmB;;;;;AAC7B","debugId":null}}]
}