{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/hooks/use-toast.ts"],"sourcesContent":["\"use client\"\n\n// Inspired by react-hot-toast library\nimport * as React from \"react\"\n\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 1000000\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\n      // but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n      onOpenChange: (open) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }\n"],"names":[],"mappings":";;;;;AAEA,sCAAsC;AACtC;;AAHA;;AAUA,MAAM,cAAc;AACpB,MAAM,qBAAqB;AAS3B,MAAM,cAAc;IAClB,WAAW;IACX,cAAc;IACd,eAAe;IACf,cAAc;AAChB;AAEA,IAAI,QAAQ;AAEZ,SAAS;IACP,QAAQ,CAAC,QAAQ,CAAC,IAAI,OAAO,gBAAgB;IAC7C,OAAO,MAAM,QAAQ;AACvB;AA0BA,MAAM,gBAAgB,IAAI;AAE1B,MAAM,mBAAmB,CAAC;IACxB,IAAI,cAAc,GAAG,CAAC,UAAU;QAC9B;IACF;IAEA,MAAM,UAAU,WAAW;QACzB,cAAc,MAAM,CAAC;QACrB,SAAS;YACP,MAAM;YACN,SAAS;QACX;IACF,GAAG;IAEH,cAAc,GAAG,CAAC,SAAS;AAC7B;AAEO,MAAM,UAAU,CAAC,OAAc;IACpC,OAAQ,OAAO,IAAI;QACjB,KAAK;YACH,OAAO;gBACL,GAAG,KAAK;gBACR,QAAQ;oBAAC,OAAO,KAAK;uBAAK,MAAM,MAAM;iBAAC,CAAC,KAAK,CAAC,GAAG;YACnD;QAEF,KAAK;YACH,OAAO;gBACL,GAAG,KAAK;gBACR,QAAQ,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC,IACxB,EAAE,EAAE,KAAK,OAAO,KAAK,CAAC,EAAE,GAAG;wBAAE,GAAG,CAAC;wBAAE,GAAG,OAAO,KAAK;oBAAC,IAAI;YAE3D;QAEF,KAAK;YAAiB;gBACpB,MAAM,EAAE,OAAO,EAAE,GAAG;gBAEpB,2EAA2E;gBAC3E,uCAAuC;gBACvC,IAAI,SAAS;oBACX,iBAAiB;gBACnB,OAAO;oBACL,MAAM,MAAM,CAAC,OAAO,CAAC,CAAC;wBACpB,iBAAiB,MAAM,EAAE;oBAC3B;gBACF;gBAEA,OAAO;oBACL,GAAG,KAAK;oBACR,QAAQ,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC,IACxB,EAAE,EAAE,KAAK,WAAW,YAAY,YAC5B;4BACE,GAAG,CAAC;4BACJ,MAAM;wBACR,IACA;gBAER;YACF;QACA,KAAK;YACH,IAAI,OAAO,OAAO,KAAK,WAAW;gBAChC,OAAO;oBACL,GAAG,KAAK;oBACR,QAAQ,EAAE;gBACZ;YACF;YACA,OAAO;gBACL,GAAG,KAAK;gBACR,QAAQ,MAAM,MAAM,CAAC,MAAM,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK,OAAO,OAAO;YAC5D;IACJ;AACF;AAEA,MAAM,YAA2C,EAAE;AAEnD,IAAI,cAAqB;IAAE,QAAQ,EAAE;AAAC;AAEtC,SAAS,SAAS,MAAc;IAC9B,cAAc,QAAQ,aAAa;IACnC,UAAU,OAAO,CAAC,CAAC;QACjB,SAAS;IACX;AACF;AAIA,SAAS,MAAM,EAAE,GAAG,OAAc;IAChC,MAAM,KAAK;IAEX,MAAM,SAAS,CAAC,QACd,SAAS;YACP,MAAM;YACN,OAAO;gBAAE,GAAG,KAAK;gBAAE;YAAG;QACxB;IACF,MAAM,UAAU,IAAM,SAAS;YAAE,MAAM;YAAiB,SAAS;QAAG;IAEpE,SAAS;QACP,MAAM;QACN,OAAO;YACL,GAAG,KAAK;YACR;YACA,MAAM;YACN,cAAc,CAAC;gBACb,IAAI,CAAC,MAAM;YACb;QACF;IACF;IAEA,OAAO;QACL,IAAI;QACJ;QACA;IACF;AACF;AAEA,SAAS;;IACP,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAc,AAAD,EAAS;IAEhD,CAAA,GAAA,6JAAA,CAAA,YAAe,AAAD;8BAAE;YACd,UAAU,IAAI,CAAC;YACf;sCAAO;oBACL,MAAM,QAAQ,UAAU,OAAO,CAAC;oBAChC,IAAI,QAAQ,CAAC,GAAG;wBACd,UAAU,MAAM,CAAC,OAAO;oBAC1B;gBACF;;QACF;6BAAG;QAAC;KAAM;IAEV,OAAO;QACL,GAAG,KAAK;QACR;QACA,SAAS,CAAC,UAAqB,SAAS;gBAAE,MAAM;gBAAiB;YAAQ;IAC3E;AACF;GAlBS","debugId":null}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,CAAA,GAAA,8JAAA,CAAA,UAAO,AAAD,EAAE,CAAA,GAAA,wIAAA,CAAA,OAAI,AAAD,EAAE;AACtB","debugId":null}},
    {"offset": {"line": 192, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/toast.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Viewport\n    ref={ref}\n    className={cn(\n      \"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n      className\n    )}\n    {...props}\n  />\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst toastVariants = cva(\n  \"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border bg-background text-foreground\",\n        destructive:\n          \"destructive group border-destructive bg-destructive text-destructive-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Toast = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &\n    VariantProps<typeof toastVariants>\n>(({ className, variant, ...props }, ref) => {\n  return (\n    <ToastPrimitives.Root\n      ref={ref}\n      className={cn(toastVariants({ variant }), className)}\n      {...props}\n    />\n  )\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Action>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Action\n    ref={ref}\n    className={cn(\n      \"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive\",\n      className\n    )}\n    {...props}\n  />\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Close>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Close\n    ref={ref}\n    className={cn(\n      \"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600\",\n      className\n    )}\n    toast-close=\"\"\n    {...props}\n  >\n    <X className=\"h-4 w-4\" />\n  </ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Title>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Title\n    ref={ref}\n    className={cn(\"text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Description>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Description\n    ref={ref}\n    className={cn(\"text-sm opacity-90\", className)}\n    {...props}\n  />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n  type ToastProps,\n  type ToastActionElement,\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastClose,\n  ToastAction,\n}\n"],"names":[],"mappings":";;;;;;;;;;AAEA;AACA;AACA;AACA;AAEA;AAPA;;;;;;;AASA,MAAM,gBAAgB,oKAAA,CAAA,WAAwB;AAE9C,MAAM,8BAAgB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAGnC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,oKAAA,CAAA,WAAwB;QACvB,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,qIACA;QAED,GAAG,KAAK;;;;;;;AAGb,cAAc,WAAW,GAAG,oKAAA,CAAA,WAAwB,CAAC,WAAW;AAEhE,MAAM,gBAAgB,CAAA,GAAA,mKAAA,CAAA,MAAG,AAAD,EACtB,6lBACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;QACJ;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAGF,MAAM,sBAAQ,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAI3B,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAO,EAAE;IACnC,qBACE,6LAAC,oKAAA,CAAA,OAAoB;QACnB,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,cAAc;YAAE;QAAQ,IAAI;QACzC,GAAG,KAAK;;;;;;AAGf;;AACA,MAAM,WAAW,GAAG,oKAAA,CAAA,OAAoB,CAAC,WAAW;AAEpD,MAAM,4BAAc,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,oKAAA,CAAA,SAAsB;QACrB,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,sgBACA;QAED,GAAG,KAAK;;;;;;;AAGb,YAAY,WAAW,GAAG,oKAAA,CAAA,SAAsB,CAAC,WAAW;AAE5D,MAAM,2BAAa,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,oKAAA,CAAA,QAAqB;QACpB,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,yVACA;QAEF,eAAY;QACX,GAAG,KAAK;kBAET,cAAA,6LAAC,+LAAA,CAAA,IAAC;YAAC,WAAU;;;;;;;;;;;;AAGjB,WAAW,WAAW,GAAG,oKAAA,CAAA,QAAqB,CAAC,WAAW;AAE1D,MAAM,2BAAa,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,oKAAA,CAAA,QAAqB;QACpB,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,yBAAyB;QACtC,GAAG,KAAK;;;;;;;AAGb,WAAW,WAAW,GAAG,oKAAA,CAAA,QAAqB,CAAC,WAAW;AAE1D,MAAM,iCAAmB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,SAGtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,oKAAA,CAAA,cAA2B;QAC1B,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,sBAAsB;QACnC,GAAG,KAAK;;;;;;;AAGb,iBAAiB,WAAW,GAAG,oKAAA,CAAA,cAA2B,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 327, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/toaster.tsx"],"sourcesContent":["\"use client\"\n\nimport { useToast } from \"@/hooks/use-toast\"\nimport {\n  Toast,\n  ToastClose,\n  ToastDescription,\n  ToastProvider,\n  ToastTitle,\n  ToastViewport,\n} from \"@/components/ui/toast\"\n\nexport function Toaster() {\n  const { toasts } = useToast()\n\n  return (\n    <ToastProvider>\n      {toasts.map(function ({ id, title, description, action, ...props }) {\n        return (\n          <Toast key={id} {...props}>\n            <div className=\"grid gap-1\">\n              {title && <ToastTitle>{title}</ToastTitle>}\n              {description && (\n                <ToastDescription>{description}</ToastDescription>\n              )}\n            </div>\n            {action}\n            <ToastClose />\n          </Toast>\n        )\n      })}\n      <ToastViewport />\n    </ToastProvider>\n  )\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;;;AAHA;;;AAYO,SAAS;;IACd,MAAM,EAAE,MAAM,EAAE,GAAG,CAAA,GAAA,+HAAA,CAAA,WAAQ,AAAD;IAE1B,qBACE,6LAAC,oIAAA,CAAA,gBAAa;;YACX,OAAO,GAAG,CAAC,SAAU,EAAE,EAAE,EAAE,KAAK,EAAE,WAAW,EAAE,MAAM,EAAE,GAAG,OAAO;gBAChE,qBACE,6LAAC,oIAAA,CAAA,QAAK;oBAAW,GAAG,KAAK;;sCACvB,6LAAC;4BAAI,WAAU;;gCACZ,uBAAS,6LAAC,oIAAA,CAAA,aAAU;8CAAE;;;;;;gCACtB,6BACC,6LAAC,oIAAA,CAAA,mBAAgB;8CAAE;;;;;;;;;;;;wBAGtB;sCACD,6LAAC,oIAAA,CAAA,aAAU;;;;;;mBARD;;;;;YAWhB;0BACA,6LAAC,oIAAA,CAAA,gBAAa;;;;;;;;;;;AAGpB;GAtBgB;;QACK,+HAAA,CAAA,WAAQ;;;KADb","debugId":null}},
    {"offset": {"line": 412, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/actions/mcp-actions.ts"],"sourcesContent":["\n'use server';\n\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport { spawn, type ChildProcess } from 'child_process';\nimport type { ToolDefinition as SdkToolDefinition } from '@modelcontextprotocol/sdk/types.js'; // Renamed to avoid conflict if McpTool is also named ToolDefinition\nimport { MCP_SERVER_CONFIGS } from '@/config/mcp-servers';\nimport type { McpServerConfig, McpServerRegistry, McpTool } from '@/types/mcp';\n\n// Define ToolDefinition locally if it's just a subset or re-export from SDK\n// For now, assuming McpTool from @/types/mcp is sufficient for internal mapping,\n// and SdkToolDefinition is what the SDK provides.\n\ninterface MCPConnection {\n  client: Client;\n  process: ChildProcess;\n  tools: SdkToolDefinition[]; // Tools as defined by the MCP SDK\n  serverConfig: McpServerConfig; // Store the original config for reference\n}\n\nclass MCPManager {\n  private connections = new Map<string, MCPConnection>();\n  private managerIsInitialized = false;\n\n  constructor() {\n    // Constructor is clean of Node.js process global event listeners\n  }\n\n  public isManagerInitialized(): boolean {\n    return this.managerIsInitialized;\n  }\n\n  public async initialize(serverRegistry: McpServerRegistry): Promise<void> {\n    if (this.managerIsInitialized) {\n      console.log('MCPManager already initialized.');\n      return;\n    }\n    console.log('MCPManager: Initializing...');\n    const connectionPromises = Object.values(serverRegistry)\n      .filter(config => config.autoConnect)\n      .map(config => this.connectServer(config));\n    \n    await Promise.allSettled(connectionPromises);\n    this.managerIsInitialized = true;\n    console.log('MCPManager: Initialization complete. Connected servers:', Array.from(this.connections.keys()));\n  }\n\n  async connectServer(serverConfig: McpServerConfig): Promise<void> {\n    if (this.connections.has(serverConfig.id)) {\n      console.log(`MCPManager: Server ${serverConfig.id} is already connected or connection attempt in progress.`);\n      return;\n    }\n\n    console.log(`MCPManager: Attempting to connect to ${serverConfig.name} (ID: ${serverConfig.id})...`);\n\n    let serverProcess: ChildProcess;\n\n    try {\n      serverProcess = spawn(serverConfig.processConfig.command, serverConfig.processConfig.args, {\n        stdio: ['pipe', 'pipe', 'pipe'], \n        env: { ...process.env, ...serverConfig.processConfig.env, NODE_ENV: process.env.NODE_ENV },\n        cwd: serverConfig.processConfig.cwd,\n      });\n      \n      serverProcess.stderr?.on('data', (data) => {\n        console.error(`MCP Server [${serverConfig.id}] stderr: ${data.toString().trim()}`);\n      });\n\n      serverProcess.on('error', (err) => {\n        console.error(`MCPManager: Failed to start server process for ${serverConfig.id}:`, err);\n        this.connections.delete(serverConfig.id); \n      });\n\n      serverProcess.on('exit', (code, signal) => {\n        console.log(`MCPManager: Server process ${serverConfig.id} exited with code ${code} and signal ${signal}`);\n        this.connections.delete(serverConfig.id);\n      });\n      \n      const transport = new StdioClientTransport({\n        reader: serverProcess.stdout,\n        writer: serverProcess.stdin,\n      });\n\n      const client = new Client(\n        { name: 'agent-computer-client', version: '1.0.0' }, \n        { capabilities: {} } \n      );\n\n      await client.connect(transport);\n      console.log(`MCPManager: Successfully established transport with ${serverConfig.name}.`);\n\n      let tools: SdkToolDefinition[] = [];\n      try {\n        const toolsResponse = await client.request<{ tools: SdkToolDefinition[] }>({ method: 'tools/list' }, {});\n        tools = toolsResponse?.tools || [];\n        console.log(`MCPManager: Fetched ${tools.length} tools from ${serverConfig.name}.`);\n      } catch (toolError) {\n        console.error(`MCPManager: Failed to list tools for ${serverConfig.name}:`, toolError);\n         await client.close();\n         if (serverProcess && !serverProcess.killed) serverProcess.kill();\n         throw toolError; \n      }\n\n      this.connections.set(serverConfig.id, {\n        client,\n        process: serverProcess,\n        tools,\n        serverConfig \n      });\n\n      console.log(`✓ MCPManager: Connected to ${serverConfig.name} (ID: ${serverConfig.id}).`);\n    } catch (error) {\n      console.error(`✗ MCPManager: Failed to connect to ${serverConfig.name} (ID: ${serverConfig.id}):`, error);\n      if (serverProcess && !serverProcess.killed) {\n        serverProcess.kill();\n      }\n      this.connections.delete(serverConfig.id);\n      // Do not re-throw here if initialize is called with allSettled,\n      // as individual connection failures are handled by allSettled.\n      // However, if connectServer is called directly, re-throwing might be desired.\n      // For now, let's assume initialize handles aggregation of results/errors.\n    }\n  }\n\n  listTools(serverId: string): SdkToolDefinition[] {\n    const connection = this.connections.get(serverId);\n    if (!connection) {\n      throw new Error(`MCPManager: Server ${serverId} not connected or connection lost.`);\n    }\n    return connection.tools;\n  }\n\n  listAllAvailableTools(): McpTool[] {\n    const allTools: McpTool[] = [];\n    for (const [serverId, connection] of this.connections.entries()) {\n      const serverTools = connection.tools || [];\n      allTools.push(...serverTools.map(tool => ({\n        name: tool.name,\n        description: tool.description,\n        inputSchema: tool.inputSchema || {}, \n        serverId: serverId,\n      })));\n    }\n    return allTools;\n  }\n  \n  getConnectedServersInfo(serverRegistryInput: McpServerRegistry): Array<Pick<McpServerConfig, 'id' | 'name' | 'description' | 'icon' | 'tags'> & {toolsCount: number}> {\n    const info: Array<Pick<McpServerConfig, 'id' | 'name' | 'description' | 'icon' | 'tags'> & {toolsCount: number}> = [];\n     for (const [serverId, connection] of this.connections.entries()) {\n        const originalConfig = connection.serverConfig;\n        info.push({\n            id: serverId,\n            name: originalConfig.name, \n            description: originalConfig.description,\n            icon: originalConfig.icon,\n            tags: originalConfig.tags,\n            toolsCount: connection.tools.length,\n        });\n    }\n    return info;\n  }\n\n  async executeTool(serverId: string, toolName: string, args: any = {}): Promise<any> {\n    const connection = this.connections.get(serverId);\n    if (!connection) {\n      throw new Error(`MCPManager: Server ${serverId} not connected or connection lost.`);\n    }\n\n    console.log(`MCPManager: Executing tool \"${toolName}\" on server \"${serverId}\" with args:`, args);\n    try {\n      const response = await connection.client.request(\n        { method: 'tools/call' },\n        { name: toolName, arguments: args }\n      );\n      console.log(`MCPManager: Tool \"${toolName}\" executed successfully on \"${serverId}\". Response:`, response);\n      return response;\n    } catch (error) {\n      console.error(`MCPManager: Error executing tool \"${toolName}\" on server \"${serverId}\":`, error);\n      throw error;\n    }\n  }\n\n  async disconnect(serverId: string): Promise<void> {\n    const connection = this.connections.get(serverId);\n    if (connection) {\n      console.log(`MCPManager: Disconnecting from server ${serverId}...`);\n      try {\n        await connection.client.close();\n      } catch (closeError) {\n        console.error(`MCPManager: Error closing client for ${serverId}:`, closeError);\n      }\n      if (connection.process && !connection.process.killed) {\n        connection.process.kill('SIGTERM'); \n        await new Promise(resolve => setTimeout(resolve, 200)); \n        if (connection.process && !connection.process.killed) {\n            console.log(`MCPManager: Server process ${serverId} did not terminate with SIGTERM, sending SIGKILL.`);\n            connection.process.kill('SIGKILL');\n        }\n      }\n      this.connections.delete(serverId);\n      console.log(`MCPManager: Disconnected from server ${serverId}.`);\n    }\n  }\n\n  async disconnectAll(): Promise<void> {\n    console.log('MCPManager: Disconnecting all server connections...');\n    const disconnectionPromises = Array.from(this.connections.keys()).map(serverId => this.disconnect(serverId));\n    await Promise.allSettled(disconnectionPromises);\n    this.connections.clear();\n    console.log('MCPManager: All server connections closed and processes terminated.');\n    this.managerIsInitialized = false;\n  }\n}\n\n\n// Singleton instance management for MCPManager within this server module\nlet mcpManagerInstance: MCPManager | null = null;\nlet managerInitializationPromise: Promise<void> | null = null;\n\nasync function getInitializedManager(): Promise<MCPManager> {\n  if (mcpManagerInstance && mcpManagerInstance.isManagerInitialized()) {\n    return mcpManagerInstance;\n  }\n\n  if (!managerInitializationPromise) {\n    console.log('MCP Actions: MCPManager instance or initialization promise not found. Creating new one.');\n    if (!mcpManagerInstance) { // Create instance only if it truly doesn't exist\n        mcpManagerInstance = new MCPManager();\n    }\n    managerInitializationPromise = mcpManagerInstance.initialize(MCP_SERVER_CONFIGS)\n      .then(() => {\n        console.log('MCP Actions: MCPManager initialized successfully.');\n      })\n      .catch((error) => {\n        console.error('MCP Actions: MCPManager initialization failed:', error);\n        mcpManagerInstance = null; \n        managerInitializationPromise = null;\n        throw error; \n      });\n  } else {\n    console.log('MCP Actions: Waiting for existing MCPManager initialization promise to complete.');\n  }\n  \n  await managerInitializationPromise;\n\n  if (!mcpManagerInstance) { // Check again after await\n    throw new Error('MCP Actions: MCPManager instance is null after initialization attempt.');\n  }\n  return mcpManagerInstance;\n}\n\nexport async function initializeAndListToolsAction(): Promise<{ tools: McpTool[]; connectedServerIds: string[] }> {\n  try {\n    const manager = await getInitializedManager();\n    const tools = manager.listAllAvailableTools();\n    // Get connected server IDs from the manager's connections map keys\n    const connectedServerIds = Array.from(manager['connections'].keys());\n    return { tools, connectedServerIds };\n  } catch (error) {\n    console.error('Error in initializeAndListToolsAction:', error);\n    return { tools: [], connectedServerIds: [] }; \n  }\n}\n\nexport async function executeMcpToolAction(serverId: string, toolName: string, args: any): Promise<any> {\n  try {\n    const manager = await getInitializedManager();\n    return await manager.executeTool(serverId, toolName, args);\n  } catch (error) {\n    console.error(`Error in executeMcpToolAction for ${toolName} on ${serverId}:`, error);\n    throw error; \n  }\n}\n\nexport async function getConnectedMcpServersInfoAction(): Promise<Array<Pick<McpServerConfig, 'id' | 'name' | 'description' | 'icon' | 'tags'> & {toolsCount: number}>> {\n    try {\n        const manager = await getInitializedManager();\n        return manager.getConnectedServersInfo(MCP_SERVER_CONFIGS);\n    } catch (error) {\n        console.error('Error in getConnectedMcpServersInfoAction:', error);\n        return [];\n    }\n}\n\nexport async function disconnectAllMcpServersAction(): Promise<void> {\n  if (mcpManagerInstance) {\n    try {\n      await mcpManagerInstance.disconnectAll();\n      mcpManagerInstance = null;\n      managerInitializationPromise = null; \n      console.log('MCP Actions: All MCP servers disconnected and manager reset.');\n    } catch (error) {\n      console.error('Error in disconnectAllMcpServersAction:', error);\n      throw error;\n    }\n  } else {\n    console.log('MCP Actions: No MCP manager instance to disconnect.');\n  }\n}\n"],"names":[],"mappings":";;;;;;;;IA4PsB;IAaA;IAUA;IAUA","debugId":null}},
    {"offset": {"line": 430, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/config/mcp-servers.ts"],"sourcesContent":["\nimport { Brain } from 'lucide-react';\nimport type { McpServerRegistry } from '@/types/mcp';\n\nexport const MCP_SERVER_CONFIGS: McpServerRegistry = {\n  'sequential-thinking': {\n    id: 'sequential-thinking',\n    name: 'Sequential Thinking MCP',\n    description: 'An MCP server for dynamic and reflective problem-solving through a structured thinking process.',\n    processConfig: {\n      command: 'npx', // Using npx to ensure tsx is resolved\n      args: ['tsx', 'src/mcp-servers/sequential-thinking-server.ts'],\n      // cwd: process.cwd(), // Optional: specify current working directory if needed\n    },\n    icon: Brain,\n    tags: ['Problem Solving', 'AI', 'Reflection'],\n    autoConnect: true, // Attempt to connect to this server on application startup\n  },\n  // Future MCP server configurations can be added here.\n  // Example:\n  // 'filesystem': {\n  //   id: 'filesystem',\n  //   name: 'Filesystem MCP',\n  //   description: 'Provides tools for interacting with the local filesystem.',\n  //   processConfig: {\n  //     command: 'npx',\n  //     args: ['@modelcontextprotocol/server-filesystem', './workspace'], // Example path\n  //   },\n  //   icon: Folder, \n  //   tags: ['Files', 'Storage', 'Local'],\n  //   autoConnect: false,\n  // },\n};\n"],"names":[],"mappings":";;;AACA;;AAGO,MAAM,qBAAwC;IACnD,uBAAuB;QACrB,IAAI;QACJ,MAAM;QACN,aAAa;QACb,eAAe;YACb,SAAS;YACT,MAAM;gBAAC;gBAAO;aAAgD;QAEhE;QACA,MAAM,uMAAA,CAAA,QAAK;QACX,MAAM;YAAC;YAAmB;YAAM;SAAa;QAC7C,aAAa;IACf;AAeF","debugId":null}},
    {"offset": {"line": 465, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/hooks/use-mcp.ts"],"sourcesContent":["\n\"use client\";\n\nimport { useState, useEffect, useCallback } from 'react';\nimport type { McpTool, McpServerRegistry } from '@/types/mcp'; // McpServerConfig removed as it's not directly used here\nimport {\n  initializeAndListToolsAction,\n  executeMcpToolAction,\n  // getConnectedMcpServersInfoAction, // We can add this later if needed for UI display\n} from '@/actions/mcp-actions';\nimport { MCP_SERVER_CONFIGS } from '@/config/mcp-servers';\n\n\nexport interface UseMCPState {\n  tools: McpTool[];\n  executeTool: (serverId: string, toolName: string, args: any) => Promise<any>;\n  isConnecting: boolean; // Represents initial connection/loading state\n  error: string | null;\n  isReady: boolean; // True when initial tools are loaded and manager is ready on server\n  connectedServers: string[]; // IDs of successfully connected servers\n}\n\nexport const useMCP = (\n  // serverConfigs parameter is kept for potential future use but not directly passed to actions currently\n  // as actions use the centrally defined MCP_SERVER_CONFIGS.\n  _serverConfigs: McpServerRegistry = MCP_SERVER_CONFIGS \n): UseMCPState => {\n  const [tools, setTools] = useState<McpTool[]>([]);\n  const [isConnecting, setIsConnecting] = useState(true); // Start as true for initial load\n  const [error, setError] = useState<string | null>(null);\n  const [connectedServers, setConnectedServers] = useState<string[]>([]);\n\n  const initializeAndLoadTools = useCallback(async () => {\n    setIsConnecting(true);\n    setError(null);\n    try {\n      console.log(\"useMCP: Calling initializeAndListToolsAction...\");\n      const result = await initializeAndListToolsAction();\n      if (result.tools && result.connectedServerIds) {\n        setTools(result.tools);\n        setConnectedServers(result.connectedServerIds);\n        console.log(`useMCP: Initialization successful. Tools: ${result.tools.length}, Connected Servers: ${result.connectedServerIds.join(', ')}`);\n      } else {\n        console.warn(\"useMCP: initializeAndListToolsAction returned unexpected data.\", result);\n        setError(\"MCP initialization returned incomplete data.\");\n        setTools([]);\n        setConnectedServers([]);\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to initialize MCP and list tools.';\n      console.error(\"useMCP: Error during initializeAndListToolsAction:\", errorMessage, err);\n      setError(errorMessage);\n      setTools([]);\n      setConnectedServers([]);\n    } finally {\n      setIsConnecting(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    initializeAndLoadTools();\n    // No explicit cleanup needed here for disconnectAll, as that's typically an app-level concern\n    // or handled by the server actions layer if needed (e.g. on app shutdown, if possible from server actions)\n  }, [initializeAndLoadTools]);\n\n  const executeMcpTool = useCallback(async (\n    serverId: string,\n    toolName: string,\n    args: any\n  ): Promise<any> => {\n    if (!connectedServers.includes(serverId)) {\n        // This check is client-side. The server action will also validate.\n        console.error(`useMCP: Attempt to execute tool on non-connected server ${serverId}`);\n        throw new Error(`MCP Server ${serverId} is not listed as connected.`);\n    }\n    try {\n      return await executeMcpToolAction(serverId, toolName, args);\n    } catch (err) {\n      console.error(`useMCP: Error executing tool ${toolName} on ${serverId} via action:`, err);\n      // Potentially set an error state here if you want to display it in the UI\n      throw err; // Re-throw to be handled by the caller UI component\n    }\n  }, [connectedServers]);\n\n  return {\n    tools,\n    executeTool: executeMcpTool,\n    isConnecting,\n    error,\n    isReady: !isConnecting && error === null && connectedServers.length > 0, // Adjusted readiness logic\n    connectedServers,\n  };\n};\n"],"names":[],"mappings":";;;AAGA;AAEA;AAKA;;AATA;;;;AAqBO,MAAM,SAAS,CACpB,wGAAwG;AACxG,2DAA2D;AAC3D,iBAAoC,kIAAA,CAAA,qBAAkB;;IAEtD,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAa,EAAE;IAChD,MAAM,CAAC,cAAc,gBAAgB,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE,OAAO,iCAAiC;IACzF,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAiB;IAClD,MAAM,CAAC,kBAAkB,oBAAoB,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAY,EAAE;IAErE,MAAM,yBAAyB,CAAA,GAAA,6JAAA,CAAA,cAAW,AAAD;sDAAE;YACzC,gBAAgB;YAChB,SAAS;YACT,IAAI;gBACF,QAAQ,GAAG,CAAC;gBACZ,MAAM,SAAS,MAAM,CAAA,GAAA,mIAAA,CAAA,+BAA4B,AAAD;gBAChD,IAAI,OAAO,KAAK,IAAI,OAAO,kBAAkB,EAAE;oBAC7C,SAAS,OAAO,KAAK;oBACrB,oBAAoB,OAAO,kBAAkB;oBAC7C,QAAQ,GAAG,CAAC,CAAC,0CAA0C,EAAE,OAAO,KAAK,CAAC,MAAM,CAAC,qBAAqB,EAAE,OAAO,kBAAkB,CAAC,IAAI,CAAC,OAAO;gBAC5I,OAAO;oBACL,QAAQ,IAAI,CAAC,kEAAkE;oBAC/E,SAAS;oBACT,SAAS,EAAE;oBACX,oBAAoB,EAAE;gBACxB;YACF,EAAE,OAAO,KAAK;gBACZ,MAAM,eAAe,eAAe,QAAQ,IAAI,OAAO,GAAG;gBAC1D,QAAQ,KAAK,CAAC,sDAAsD,cAAc;gBAClF,SAAS;gBACT,SAAS,EAAE;gBACX,oBAAoB,EAAE;YACxB,SAAU;gBACR,gBAAgB;YAClB;QACF;qDAAG,EAAE;IAEL,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;4BAAE;YACR;QACA,8FAA8F;QAC9F,2GAA2G;QAC7G;2BAAG;QAAC;KAAuB;IAE3B,MAAM,iBAAiB,CAAA,GAAA,6JAAA,CAAA,cAAW,AAAD;8CAAE,OACjC,UACA,UACA;YAEA,IAAI,CAAC,iBAAiB,QAAQ,CAAC,WAAW;gBACtC,mEAAmE;gBACnE,QAAQ,KAAK,CAAC,CAAC,wDAAwD,EAAE,UAAU;gBACnF,MAAM,IAAI,MAAM,CAAC,WAAW,EAAE,SAAS,4BAA4B,CAAC;YACxE;YACA,IAAI;gBACF,OAAO,MAAM,CAAA,GAAA,mIAAA,CAAA,uBAAoB,AAAD,EAAE,UAAU,UAAU;YACxD,EAAE,OAAO,KAAK;gBACZ,QAAQ,KAAK,CAAC,CAAC,6BAA6B,EAAE,SAAS,IAAI,EAAE,SAAS,YAAY,CAAC,EAAE;gBACrF,0EAA0E;gBAC1E,MAAM,KAAK,oDAAoD;YACjE;QACF;6CAAG;QAAC;KAAiB;IAErB,OAAO;QACL;QACA,aAAa;QACb;QACA;QACA,SAAS,CAAC,gBAAgB,UAAU,QAAQ,iBAAiB,MAAM,GAAG;QACtE;IACF;AACF;GAtEa","debugId":null}},
    {"offset": {"line": 558, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/contexts/mcp-context.tsx"],"sourcesContent":["\n\"use client\";\n\nimport React, { createContext, useContext, type ReactNode } from 'react';\nimport { useMCP, type UseMCPState } from '@/hooks/use-mcp';\nimport { MCP_SERVER_CONFIGS } from '@/config/mcp-servers'; // Ensure this path is correct\n\n// Define a default state that matches UseMCPState structure\nconst defaultMCPState: UseMCPState = {\n  tools: [],\n  executeTool: async () => { throw new Error('MCPContext not yet initialized'); },\n  isConnecting: true,\n  error: null,\n  isReady: false,\n  connectedServers: [],\n};\n\nconst MCPContext = createContext<UseMCPState>(defaultMCPState);\n\nexport const MCPProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const mcpState = useMCP(MCP_SERVER_CONFIGS); // Pass the configurations here\n\n  return (\n    <MCPContext.Provider value={mcpState}>\n      {children}\n    </MCPContext.Provider>\n  );\n};\n\nexport const useMCPContext = (): UseMCPState => {\n  const context = useContext(MCPContext);\n  if (context === undefined) {\n    throw new Error('useMCPContext must be used within an MCPProvider');\n  }\n  return context;\n};\n"],"names":[],"mappings":";;;;;AAGA;AACA;AACA,mOAA2D,8BAA8B;;;AAJzF;;;;AAMA,4DAA4D;AAC5D,MAAM,kBAA+B;IACnC,OAAO,EAAE;IACT,aAAa;QAAc,MAAM,IAAI,MAAM;IAAmC;IAC9E,cAAc;IACd,OAAO;IACP,SAAS;IACT,kBAAkB,EAAE;AACtB;AAEA,MAAM,2BAAa,CAAA,GAAA,6JAAA,CAAA,gBAAa,AAAD,EAAe;AAEvC,MAAM,cAAiD,CAAC,EAAE,QAAQ,EAAE;;IACzE,MAAM,WAAW,CAAA,GAAA,6HAAA,CAAA,SAAM,AAAD,EAAE,kIAAA,CAAA,qBAAkB,GAAG,+BAA+B;IAE5E,qBACE,6LAAC,WAAW,QAAQ;QAAC,OAAO;kBACzB;;;;;;AAGP;GARa;;QACM,6HAAA,CAAA,SAAM;;;KADZ;AAUN,MAAM,gBAAgB;;IAC3B,MAAM,UAAU,CAAA,GAAA,6JAAA,CAAA,aAAU,AAAD,EAAE;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;IANa","debugId":null}}]
}